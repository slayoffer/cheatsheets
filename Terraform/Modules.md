### Basics

```bash
# Модуль — набор конфигурационных файлов в одной директории. Если в каталоге лежит хотя бы один файл конфигурации Terraform .tf — это уже модуль.

# Структура модуля обычно выглядит так (нестрогое требование):
├── LICENSE
├── README.md
├── main.tf
├── modules/
├── variables.tf
├── outputs.tf 

LICENSE — информация о лицензии, по которой будет распространяться ваш модуль. Сам Terraform не использует этот файл. Всего лишь правило хорошего тона.

README.md — документация, в которой написано, как использовать ваш модуль. Terraform не использует этот файл, но Terraform Registry и GitHub на основе этого файла показывают пользователям информацию о модуле.

main.tf — основной набор настроек для модуля. Можно создавать и другие файлы конфигурации и называть так, как удобно для текущего модуля.

modules. — подкаталог для подключаемых модулей. Тут хранятся модули, которые нужны для работы текущего модуля.

variable.tf — значения всех переменных, которые необходимы для работы модуля. Можно переопределить в других модулях при необходимости.

outputs.tf — определения вывода для вашего модуля. Удобно для передачи информации о частях вашей инфраструктуры, определённых модулем, в другие части конфигурации.

Ещё подробнее про структуру модулей можно почитать тут:
https://www.terraform.io/language/modules/develop/structure
```

### Add module

```bash
# Модули бывают корневые (root) и дочерние (child). Корневой — наш модуль, а дочерними будут все модули, которые мы подключим в корневом. 

# Дочерние модули можно хранить локально, положить в папку modules в рутовом модуле, или брать с удалённых registry (gitgub, http url, terraform registry).

# Модули подключаются при помощи блока module в конфигурации main.tf.

# Представим, что у нас есть модуль tf-yc-postgresdb и мы хотим его использовать в другом модуле. Для этого в корневом модуле создадим директорию modules и положим в неё модуль tf-yc-postgresdb, а в main.tf допишем:

module "yandex_cloud_postgresdb" {
  source = "./modules/tf-yc-postgresdb"
} 
```

### Refactoring

```bash
# Рефакторинг предлагает Terraform работать со «старым» объектом, как с «новым», то есть «старый» объект не уничтожается.

# Terraform сопоставляет каждый модуль и уникальный адрес ресурса, поэтому перемещение или переименование объекта = уничтожить «старый» объект + создать «новый».

# для этого используется блок 
moved

# https://www.terraform.io/language/modules/develop/refactoring#renaming-a-resource
```

### Meta arguments

```bash
# Язык Terraform определяет несколько мета-аргументов, которые можно использовать с любым типом ресурсов для изменения их поведения. 
# К ним относятся:
depends_on — для указания скрытых зависимостей.

count — для создания нескольких экземпляров ресурсов, количество экземпляров = count. 
Подробности тут:
https://www.terraform.io/language/meta-arguments/count

for_each создаёт несколько экземпляров модуля из одного блока модуля. 
За подробностями сюда:
https://www.terraform.io/language/meta-arguments/for_each

provider — для выбора конфигурации провайдера. 
Дополнительно читать тут:
https://www.terraform.io/language/meta-arguments/module-providers

lifecycle — для настройки жизненного цикла. Сейчас не используется, но зарезервирован на будущее.

За подробностями по мета-аргументам стоит заглянуть сюда:
# https://www.terraform.io/language/resources/syntax#meta-arguments
```

