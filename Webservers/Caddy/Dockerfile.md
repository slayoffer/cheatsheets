Выполним:

Скопировать код

```
 mkdir caddy
 cd caddy 
```

Создадим конфиг Caddy:

Скопировать код

```
:8080 {
        respond "Hi there"
} 
```

Создадим Dockerfile:

```
FROM debian:buster
RUN apt update
RUN apt install -y curl debian-keyring debian-archive-keyring apt-transport-https
RUN curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | tee /etc/apt/trusted.gpg.d/caddy-stable.asc
RUN curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | tee /etc/apt/sources.list.d/caddy-stable.list
RUN apt update
RUN apt install -y caddy
RUN mkdir caddy
RUN cd caddy
COPY ./Caddyfile /caddy/Caddyfile
WORKDIR /caddy
EXPOSE 8080/tcp
ENTRYPOINT ["caddy","run"] 
```

- `FROM` — какой базовый образ взять.
- `RUN` — какая команда выполнится внутри данного образа.
- `COPY` — просто копирует файл из файловой системы хоста в файловую систему контейнера; сначала надо указать файл с хоста, а затем путь в контейнере.
- `ADD` — может не просто копировать файлы, как COPY, но и, например, скачивать по http, поэтому инструкция COPY предпочтительней при создании образов, потому что делает добавление файлов в образ более прозрачным.
- `WORKDIR` — текущий каталог при старте контейнера.
- `EXPOSE` — список портов, используемых контейнеризованным процессом. Но реально порты не открываются наружу это инструкцией, это лишь для справки тем, кто использует данный образ.
- `ENTRYPOINT` — какой процесс необходимо запустить при старте контейнера и его аргументы

При запуске `docker run <имя образа> <что нужно добавить к вызову, указанному в ENTRYPOINT-образа>`, если Dockerfile, на основе которого был сделан образ, не содержал ENTRYPOINT, то выполнится только команда, например: `docker run <имя образа> <команда в образе>`.

А ещё команды типа `RUN`, `COPY` и `ADD` приводят к созданию нового слоя в образе, поэтому надо быть экономнее и объединять их и удалять ненужные файлы, если есть.

Для запуска процесса в контейнере обычно используют либо `RUN`, либо `ENTRYPOINT`, либо `CMD`. `RUN` хорош для служебных действий вроде установки пакетов или смены каталога. Чтобы запустить основной процесс контейнера, используют `ENTRYPOINT` или `CMD`, без них контейнер не взлетит. 

Основная разница между ними в том, что при использовании `CMD` параметры командной строки, которые вы можете передать в момент запуска контейнера в командной строке, могут перезаписать параметры, указанные в Dockerfile. В случае с `ENTRYPOINT`, параметры из командной строки не могут перезаписать значения из Dockerfile, но будут либо игнорироваться (`shell form`), либо добавятся к ним (`exec form`). Кроме того, `CMD` и `ENTRYPOINT` могут работать вместе, сохраняя своё поведение.

Например, можно было бы этот Dockerfile переписать так:

```
FROM debian:buster-20220527
RUN apt update && \ 
    apt install -y curl debian-keyring debian-archive-keyring apt-transport-https && \
    curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg && \
    curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | tee /etc/apt/sources.list.d/caddy-stable.list && \
    apt update && apt install -y caddy
WORKDIR /caddy
COPY ./Caddyfile /caddy/Caddyfile
EXPOSE 8080/tcp
ENTRYPOINT ["caddy","run"] 
```

Можно удалить неиспользуемый `curl` из образа и посклеивать команды. Это нужно, чтобы уменьшить образ, а также убрать из него лишние инструменты (чем больше приложений, тем больше возможностей для атаки). Но пока не будем, `curl` ещё пригодится в образе для ряда экспериментов.

Выполним:

```
 docker build -t my-caddy-image:0.0.1 . 
```

**Примечание:** если вдруг вы уже делали такой образ и хотите перебилдить заново, то лучше удалить старый и пересобрать. Либо собрать образ и протегировать его новой версией, например, `0.0.2`.

```
 docker rmi -f image my-caddy-image:0.0.1
 docker build --no-cache -t my-caddy-image:0.0.1 .
 //Ключ --no-cache, чтобы образ пересобрался полностью. Т.к Докер кэширует слои при сборке 
```

- Ключ `-t` — чтобы указать `<имя образа>:<тег>`. **Тег** — это что-то вроде метки, дабы легко найти образ в репозитории.
- Это может быть как конкретная версия образа, так и тег latest — последний собранный образ, либо вообще тег может быть навешан на несколько образов, обобщая их.
- Последняя точка в команде сборки — путь до контекста сборки (Dockerfile и другие файлы, относящиеся к сборке). В данном случае — текущий каталог.

Проверим, что образ попал в локальный репозиторий:

```
 docker images 
```

Теперь запустим контейнер, созданный из нашего образа. Если остался старый контейнер, то его можно удалить с помощью `docker rm`, а `docker rm $(docker ps -qa)` удалит все контейнеры. `ps -qa` покажет короткие id всех контейнеров.

```
  docker run -d --rm --name caddy my-caddy-image:0.0.1 
```

Ключ `-d` — чтобы запустить контейнер в фоне и получить обратно консоль.

Проверим, что контейнер стартанул:

```
  docker ps 
```

Кстати, через команду `docker logs -f <имя контейнера>`можно посмотреть логи процесса внутри контейнера.

Ключ `-f` — чтобы логи показывались в реальном времени, а не просто вывелись один раз.

```
  docker logs -f caddy 
```

Нажмём Ctrl+C и выйдем из просмотра логов.

Проверим, что Caddy отдаёт на порту 8080 страничку в контейнере:

```
  docker exec -it caddy curl localhost:8080  
```

Давайте сначала уничтожим старый контейнер, если остался:

```
  docker rm -f caddy 
```

Ключ `-f` — **forced**, это принудительное убийство контейнера. Если вам неохота делать `docker stop <имя контейнера>`, чтобы остановить контейнер, а затем `docker rm <имя контейнера>` для удаления остановленного контейнера.

А теперь на хосте создадим папку c конфигом Caddy:

```
mkdir -p ~/caddy/conf
//и в ней создадим файл Caddyfile
cd ~/caddy/conf
tee -a Caddyfile << END 
 :8080 {
        respond "Hi there, Arseniy and Andrey"
   }
END    
```

Возьмём наш образ `my-caddy-image:0.0.1`, создадим из него контейнер, и примонтируем нашу папку с конфигом, которая заменит те, что были в образе:

```
  docker run --rm --name caddy -p 9999:8080 -v ~/caddy/conf:/caddy my-caddy-image:0.0.1 
```

Проверим в браузере страничку `<IP хоста студента>:9999`.